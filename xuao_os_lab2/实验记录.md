### 主要函数的作用

#### std::vector<std::string> args = split(cmd, " ");

这个函数是将字符串 cmd 进行划分，划分可以按照空格，也可以修改为其他的，取决于本函数的第二个参数是什么

#### .c_str()

c_str() 就是把 string 类对象转换成和 c 兼容的 char * 类型。

#### i->find('=')

i 是 vertor 中变量的下标，这个函数实现了在所有 vector 变量中找到含 ‘=’ 的，并返回其下标

#### fork()

创建子进程。子进程与父进程拥相同的代码、堆、栈等，子进程和父进程将从 fork() 语句的下一条开始执行，并不能区别出先后顺序。

fork() 函数的一大特点是：一次调用，两个返回值。父进程调用后即可创建子进程。在父进程中，它的返回值是子进程的 pid，而子进程中，它的返回值是 0。根据返回值的不同，就可以用`if(pid==0)` 和 `else` 来让子进程执行与父进程不同的内容。

#### execvp(file,argv[])

execvp() 会从 PATH 环境变量所指的目录中查找符合参数 file 的文件名，找到后便执行该文件，然后将第二个参数 argv 传给该欲执行的文件。

如果执行成功则函数**不会返回**，执行失败则直接返回-1，失败原因存于errno中。

#### substr(string,start,length)

截取字符串。string 就是要被截取的字符串，从第 start 个字符开始截取，截取的字符串长度为 length. length 可缺省，缺省时表示截取从 start 开始的所有字符

#### pipe(fd)、close

创建一个管道，名称为 fd，fd 是一个整形数组，它包括 fd[0] 和 fd[1]，fd[1] 是管道的写端，fd[0] 是管道的读端。管道是半双工，也即管道内的通信时单方向的，从写端到读端。管道是进程间通信最常用的方法之一。

两个进程之间是如何建立管道的呢？

> 一个进程用 pipe() 系统调用创建管道，然后用 fork() 调用创建一个或多个进程，那么，管道将可供所有这些进程使用。这里要注意两个系统调用的先后顺序。

以父进程与子进程通过管道进行通信为例：

父进程首先调用 pipe(fd) 创建一个管道，然后 fork() 出一个子进程，那么子进程也同时拥有了这个管道。这个过程如下图所示：

![image-20220426193918655](D:\desktop\OS\小实验\Lab2\image\pipe.png)

然后，比如说，我们本次通信是从父进程到子进程，那么，我们就在父进程中关闭读端，在子进程中关闭写端。

代码如下：

```c++
// parent:
close(fd[0]) // 父进程关闭读端
write(fd[1], &buf, sizeof(buf)); // 父进程往写端写入数据
// child:
close(fd[1]); // 子进程关闭写端
read(fd[0], &buf, sizeof(buf)); // 子进程从读端读取数据
```

注：本次实验中，并不会用到上述代码中的 write 和 read 函数，放在这里只是为了加深理解

最后一个关键的问题：为什么这两个进程都关闭它所不需的管道端呢？

> 其实父子进程的 fd 是对读写端文件描述符的引用，每一个引用都会增加引用计数，只有当引用计数为 0 时才会真正的关闭文件描述符。那么就引入如下的问题：
> 当 read() 从内核缓存读取数据时，直到数据读完，并且另一端的写端全部关闭时，read() 返回 0。否则，如果 write 没有完全关闭，当 read 读取完最后一个数据，再次读取时会阻塞而不会关闭。
> 并且，如果子进程出现阻塞而不是关闭，那么当父进程结束时，子进程仍会阻塞在后台，成为孤儿进程，并且子进程会被 init 进程收养。

#### dup 和 dup2

作用都是用来复制一个问价你的描述符

**int dup(int fd)**

源描述符 fd, 返回值是描述符表中最小的文件描述符，返回的描述符和源描述符 fd 指向同一个文件。

**int dup2(int fd, int fd2)**

dup2 函数成功返回时，目标描述符 fd2, 将变成源描述符 fd 的复制品，换句话说，两个文件描述符现在都指向同一个文件，即函数第一个参数 fd 指向的文件。

**用于管道**

一般而言，0、1、2 描述符分别被标准输入、输出、错误占用。如果我们想把标准输入换成管道输入，可用 `dup2(fd[0], 0)`，当前进程的输入就由 stdin 变成了来自管道 fd 的输入

#### open(filename, , )

```c++
O_RDONLY //只读方式打开
O_WRONLY //只写方式打开
O_RDWR   //可写可读方式打开
//可选项：
O_APPEND //表示追加
O_CREAT  //若此文件不存在就创建，此文件需要提供第三个参数mode，表示该文件的访问权限
O_EXCL   //如果同时指定链O_CREATE,并且文件已存在，则出错返回。
O_TRUNC  //如果文件已存在，并且以只写或者可读科协方式打开。则将其长度截断为0字节
O_NONBLOCK //对于设备文件，以O_NONBLOCK方式打开可以做非阻塞I/O
```

#### signal

```
typedef void (*sighandler_t) (int);
sighandler_t signal(int sig,sighandler_t handler);
```

有两个参数，第一个是信号的编号，也就是具体是哪一个信号，比如说可以是以下值：

> SIGABRT，SIGFPE,SIGILL,SIGINT,SIGSEGV,SIGTERM

第二个参数 handler：handler 这个函数必须有一个 int 类型的参数（即接收到的信号代码），它本身的类型是 void。可以是 `SIG_IGN`，代表忽略信号；也可以是 `SIG_DFL` 恢复默认行为；也可以自己写个信号处理函数。

+ ctrl+c 对应的信号是 SIGINT

#### waitpid

`pid_t waitpid(pid_t pid, int * status, int options);`

三个参数：pid ，指向返回状态所在单元的指针，用来指定可选项的标识符。

+ pid==-1，则等待任何一个子进程；pid>0，则等待 pid 指定的那个进程结束；pid == 0，则等待与调用者在用一个进程组中的任意子进程。

+ options: 提供了一些额外的选项来控制 waitpid，如果是 WNOHANG，即使没有子进程退出，他也会立即返回，不会一直等待。

返回值：正常返回，则返回收集到的子进程的进程 ID；如果设置了 WNOHANG，而 waitpid 发现没有已退出的子进程可收集，则返回 0；如果调用过程中出错，则返回 -1，如果 pid 所指示的子进程不存在，或者存在但不是调用进程的子进程，waitpid 就会出错返回

#### ptrace

[(7条消息) strace实现原理：ptrace系统调用_rtoax的博客-CSDN博客_strace windows](https://blog.csdn.net/Rong_Toa/article/details/109825818)

##### 概述

用于进程跟踪，它提供了父进程可以观察和控制其子进程执行的能力，并允许父进程检查和替换子进程的内核镜像（包括寄存器）的值。

其基本原理是：当使用了 ptrace 跟踪后，所有发给被跟踪的子进程的信号（除了 SIGKILL），都会被转发给父进程，而子进程会被阻塞。这时子进程的状态就变成了 TASK_TRACED，而父进程收到信号后，就可以对停下来的子进程进行检查和修改，然后让子进程继续运行。

##### 函数

`#include<sys/ptrace.h>`

`long ptrace(enum_ptrace_request request, pid_t pid, void *addr, void *data);`

+ enum_ptrace_request：指示了 ptrace 要执行的命令

  一些 request

  > PTRACE_TRACEME：创建子进程后，子进程使用该参数调用`ptrace`，表示子进程要求父进程对其进行跟踪。该进程之后所有对exec()的系统调用都会产生一个SIGTRAP信号发送给父进程，这使得父进程有机会在新程序还是执行前获取对子进程的控制权
  >
  > PTRACE_GETREGS：获取子进程的寄存器数据

+ pid：指示要跟踪的进程

+ void *addr：指示要监控的内存地址

+ void *data：存放读取出的或者要写入的数据

##### 实现过程



### 主要的变量

#### cmd

读入的一整行命令，需要对其进行操作

#### args

args 是字符串数组，它是将完整的命令按空格进行划分



### 实现管道

首先，需要将原来的一整行命令，按照 ‘|’ 进行划分。这一步也可以判断有无管道：若划分后，还是一个整字符串，那就说明没有 ‘|’，则无需进行管道的处理。

划分后的字符串数组记为 cmds, 命令的个数为 cmds.size()，记为 cmdv. 共需要创建 cmdv 个子进程，分别执行各条命令。共需创建 cmdv - 1 个管道，用于相邻两条指令之间的通信。

这里需要注意的是，在不含管道的命令执行时，是在最初的父进程执行，有些外部命令需要新建子进程来完成，毕竟 execvp() 不会返回。而管道命令中，在处理每一条指令时，已经是在子进程中了，所以不需要额外创建子进程。

**增加了对多余空格的删除操作**



### 实现重定向

主要基于 dup2 函数



### 处理 Ctrl-C

利用 signal 函数



### 支持 History 

在 main 函数里，每次读入一行就存入容器，然后对当前命令行特判是不是 history 或者 ！



### tiny strace

ptrace 的实现原理，结合实验文档和下面这个链接进行学习（其实对下面这个链接中的最终代码稍作修改，就能完成 tiny strace 的基础部分）

 [(7条消息) strace实现原理：ptrace系统调用_rtoax的博客-CSDN博客_strace windows](https://blog.csdn.net/Rong_Toa/article/details/109825818)

